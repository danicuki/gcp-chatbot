// Generated by CoffeeScript 1.12.7
(function() {
  var csv, fs, language, options, path, ref, version_group, write_json;

  csv = require('csv');

  fs = require('fs');

  path = (ref = process.argv[2]) != null ? ref : __dirname + '/pokedex/pokedex/data/csv';

  options = {
    delimiter: ',',
    escape: '"',
    columns: true
  };

  language = '9';

  version_group = '15';

  write_json = function(filename, object) {
    return fs.writeFile(__dirname + '/' + filename, JSON.stringify(object, null, 2));
  };

  Array.prototype.unique = function() {
    var i, key, output, ref1, results, value;
    output = {};
    for (key = i = 0, ref1 = this.length; 0 <= ref1 ? i < ref1 : i > ref1; key = 0 <= ref1 ? ++i : --i) {
      output[this[key]] = this[key];
    }
    results = [];
    for (key in output) {
      value = output[key];
      results.push(value);
    }
    return results;
  };

  fs.exists(path, function(exists) {
    if (exists) {
      csv().from.path(path + "/pokemon.csv", options).to.array(function(rows) {
        var i, len, pokemons, row;
        pokemons = {};
        for (i = 0, len = rows.length; i < len; i++) {
          row = rows[i];
          if (row.is_default === '1') {
            pokemons[row.id] = {
              id: +row.id,
              name: '',
              types: [],
              stats: {},
              moves: [],
              weight: +row.weight,
              height: +row.height
            };
          }
        }
        return csv().from.path(path + "/pokemon_species_names.csv", options).to.array(function(rows) {
          var j, len1;
          for (j = 0, len1 = rows.length; j < len1; j++) {
            row = rows[j];
            if (row.local_language_id === language) {
              pokemons[row.pokemon_species_id].name = row.name;
            }
          }
          return csv().from.path(path + "/pokemon_types.csv", options).to.array(function(rows) {
            var k, len2;
            for (k = 0, len2 = rows.length; k < len2; k++) {
              row = rows[k];
              if (pokemons[row.pokemon_id]) {
                pokemons[row.pokemon_id].types.push(+row.type_id);
              }
            }
            return csv().from.path(path + "/pokemon_stats.csv", options).to.array(function(rows) {
              var l, len3, stats;
              stats = {
                1: 'hp',
                2: 'attack',
                3: 'defense',
                4: 'spattack',
                5: 'spdefense',
                6: 'speed'
              };
              for (l = 0, len3 = rows.length; l < len3; l++) {
                row = rows[l];
                if (pokemons[row.pokemon_id]) {
                  pokemons[row.pokemon_id].stats[stats[row.stat_id]] = +row.base_stat;
                }
              }
              return csv().from.path(path + "/pokemon_moves.csv", options).to.array(function(rows) {
                var len4, m, ref1;
                for (m = 0, len4 = rows.length; m < len4; m++) {
                  row = rows[m];
                  if (row.version_group_id === version_group && (+row.pokemon_move_method_id < (ref1 = 5 + row.move_id) && ref1 < 10000)) {
                    if (pokemons[row.pokemon_id]) {
                      pokemons[row.pokemon_id].moves.push(+row.move_id);
                    }
                  }
                }
                return csv().from.path(path + "/pokemon_species.csv", options).to.array(function(rows) {
                  var evolutions, len5, n;
                  evolutions = {};
                  for (n = 0, len5 = rows.length; n < len5; n++) {
                    row = rows[n];
                    evolutions[row.id] = {
                      id: +row.id,
                      chain: +row.evolution_chain_id,
                      preevolution: +row.evolves_from_species_id
                    };
                  }
                  return csv().from.path(path + "/evolution_chains.csv", options).to.array(function(rows) {
                    var chain, evolution, id, len6, len7, link, o, p;
                    for (o = 0, len6 = rows.length; o < len6; o++) {
                      row = rows[o];
                      chain = (function() {
                        var results;
                        results = [];
                        for (id in evolutions) {
                          evolution = evolutions[id];
                          if (evolution.chain === +row.id) {
                            results.push(evolution);
                          }
                        }
                        return results;
                      })();
                      chain.sort(function(a, b) {
                        switch (false) {
                          case !(a.preevolution === 0 || b.preevolution === a.id):
                            return -1;
                          case !(b.preevolution === 0 || a.preevolution === b.id):
                            return 1;
                          default:
                            return 0;
                        }
                      });
                      for (p = 0, len7 = chain.length; p < len7; p++) {
                        link = chain[p];
                        if (link.preevolution !== 0) {
                          pokemons[link.id].moves = pokemons[link.id].moves.concat(pokemons[link.preevolution].moves);
                        }
                        pokemons[link.id].moves = pokemons[link.id].moves.unique();
                      }
                    }
                    return write_json('pokemon.json', pokemons);
                  });
                });
              });
            });
          });
        });
      });
      csv().from.path(path + "/moves.csv", options).to.array(function(rows) {
        var damages, i, len, moves, row;
        moves = {};
        damages = {
          1: 'non-damaging',
          2: 'physical',
          3: 'special'
        };
        for (i = 0, len = rows.length; i < len; i++) {
          row = rows[i];
          if (row.id < 10000 && +row.effect_id < 10000) {
            moves[row.id] = {
              id: +row.id,
              name: '',
              type: +row.type_id,
              power: +row.power,
              accuracy: +row.accuracy,
              pp: +row.pp,
              priority: +row.priority,
              damage_class: damages[+row.damage_class_id],
              effect: +row.effect_id,
              effect_chance: +row.effect_chance
            };
          }
        }
        return csv().from.path(path + "/move_names.csv", options).to.array(function(rows) {
          var j, len1;
          for (j = 0, len1 = rows.length; j < len1; j++) {
            row = rows[j];
            if (row.local_language_id === language) {
              if (moves[row.move_id] != null) {
                moves[row.move_id].name = row.name;
              }
            }
          }
          return write_json('moves.json', moves);
        });
      });
      return csv().from.path(path + "/type_names.csv", options).to.array(function(rows) {
        var i, len, row, types;
        types = {};
        for (i = 0, len = rows.length; i < len; i++) {
          row = rows[i];
          if (row.local_language_id === language && row.type_id < 10000) {
            types[row.type_id] = {
              id: +row.type_id,
              name: row.name,
              offense: {},
              defense: {}
            };
          }
        }
        return csv().from.path(path + "/type_efficacy.csv", options).to.array(function(rows) {
          var j, len1;
          for (j = 0, len1 = rows.length; j < len1; j++) {
            row = rows[j];
            types[row.damage_type_id].offense[row.target_type_id] = row.damage_factor / 100;
            types[row.target_type_id].defense[row.damage_type_id] = row.damage_factor / 100;
          }
          return write_json('types.json', types);
        });
      });
    } else {
      return console.log("Usage: coffe " + process.argv[1] + " path/to/csvs\n");
    }
  });

}).call(this);
